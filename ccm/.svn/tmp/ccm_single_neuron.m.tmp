function Unit = ccm_single_neuron(subjectID, sessionID, plotFlag, unitArray)

%
% function dataInh = ccm_single_neuron(subjectID, sessionID, plotFlag, figureHandle)
%
% Single neuron analyses for choice countermanding task. Only plots the
% sdfs. To see rasters, use ccm_single_neuron_rasters, which displays all
% conditions in a given epoch
%
% Returns Unit structure with fields:
%
%   nGo
%   nGoRight
%   nStopIncorrect
%   nStopIncorrectRight
%   goRightLogical
%   goRightSignalStrength
%   stopRightLogical
%   stopRightSignalStrength

%%
subjectID = 'Broca';
sessionID = 'bp080n01';
% sessionID = 'bp081n01';

clear Unit
% constants
DO_STOPS = 1;
MIN_RT = 120;
MAX_RT = 1200;
STD_MULTIPLE = 3;
epochArray = {'targOn', 'checkerOn', 'stopSignalOn', 'responseOnset'};
nEpoch = length(epochArray);
epochRange = -499 : 500;
epochRange = -499 : 700;

% kernelMethod = 'postsynaptic potential';
% GROWTH = 1;
% DECAY = 20;

kernelMethod = 'gaussian';
SIGMA = 15;
% kernelIn = [SIGMA];






% Load the data
[dataFile, localDataPath, localDataFile] = data_file_path(subjectID, sessionID);
% If the file hasn't already been copied to a local directory, do it now
if exist(localDataFile, 'file') ~= 2
    copyfile(dataFile, localDataPath)
end
load(localDataFile);

if ~strcmp(SessionData.task.taskID, 'ccm')
    fprintf('Not a choice countermanding session, try again\n')
    return
end

if nargin < 3, plotFlag = 1; end
if nargin < 4, unitArray = SessionData.spikeUnitArray; end

unitArray = SessionData.spikeUnitArray;
% How many units were recorded?
nUnit = size(unitArray, 2);
% Convert cells to doubles if necessary
trialData = cell_to_mat(trialData);
allRT = trialData.responseOnset - trialData.responseCueOn;
[allRT, outlierTrial] = truncate_rt(allRT, MIN_RT, MAX_RT, STD_MULTIPLE);
% outlierTrial = [];









nTrial = size(trialData, 1);
targ1PropArray = unique(trialData.targ1CheckerProp);
targ1PropArray(isnan(targ1PropArray)) = [];
% If doing a 50% condition, add an extra one to targ1PropArray so there's
% one for rightward and leftward (randomly assigned) targets (see below)
if ismember(.5, targ1PropArray)
    [a, i] = ismember(.5, targ1PropArray);
    targ1PropArray = [targ1PropArray(1:i); .5; targ1PropArray(i+1:end)];
end
nSignal = length(targ1PropArray);

% switch subjectID
%     case 'Broca'
%         signalStrengthArray = [.41 .45 .48 .5 .52 .55 .59];
%     case 'Xena'
%         signalStrengthArray = [.35 .42 .47 .5 .53 .58 .65];
%     otherwise
% end

% Need to do a little SSD value adjusting, due to ms difference and 1-frame
% differences in SSD values
ssdArrayRaw = trialData.stopSignalOn - trialData.responseCueOn;
ssdArray = unique(ssdArrayRaw);
ssdArray = ssdArray(~isnan(ssdArray));
if ~isempty(ssdArray) && DO_STOPS
    a = diff(ssdArray);
    ssdArray(a == 1) = ssdArray(a == 1) + 1;
    ssdArray = unique(ssdArray);
    b = [ssdArray(1); diff(ssdArray)];
    ssdArray(b < 13) = [];
end



% If there weren't stop trials, skip all stop-related analyses
if isempty(ssdArray) || ~DO_STOPS
    data = [];
    disp('ccm_inhibition.m: No stop trials or stop trial analyses not requested');
    return
end






nCondition = 5;
sdfMax = zeros(nUnit, nEpoch, nSignal, nCondition);  % Keep track of maximum sdf values, for setting y-axis limits in plots

for kUnitIndex = 1 : nUnit
    Unit(kUnitIndex).name = unitArray{kUnitIndex};
    %     unitArray{kUnitIndex}
    
    for iPropIndex = 1 : length(targ1PropArray);
        iPct = targ1PropArray(iPropIndex) * 100;
        
        
        %   Go trials:
        ssdRange = 'none';
        
        % If it's not 50% or if there's only one 50% condition in
        % targPropArray
        if iPct ~= 50 || (iPct == 50 &&  targ1PropArray(iPropIndex-1) ~= 50 &&  targ1PropArray(iPropIndex+1) ~= 50)
            targetHemifield = 'all';
            % If it's the first 50% condition
        elseif iPct == 50 && targ1PropArray(iPropIndex-1) ~= 50
            targetHemifield = 'left';
            % If it's the second 50% condition
        elseif iPct == 50 && targ1PropArray(iPropIndex-1) == 50
            targetHemifield = 'right';
        end
        iGoTargTrial = ccm_trial_selection(trialData, {'goCorrectTarget'; 'targetHoldAbort'}, iPct, ssdRange, targetHemifield);
        iGoDistTrial = ccm_trial_selection(trialData, {'goCorrectDistractor', 'distractorHoldAbort'}, iPct, ssdRange, targetHemifield);
        iGoTargTrial(ismember(iGoTargTrial, outlierTrial)) = [];
        iGoDistTrial(ismember(iGoDistTrial, outlierTrial)) = [];
        
        for mEpoch = 1 : length(epochArray)
            mEpochName = epochArray{mEpoch};
            if ~strcmp(mEpochName, 'stopSignalOn')  % No stop signals on go trials
                
                % Go to Target trials
                alignmentTimeList = trialData.(mEpochName)(iGoTargTrial);
                [alignedRasters, alignmentIndex] = spike_to_raster(trialData.spikeData(iGoTargTrial, kUnitIndex), alignmentTimeList);
                Unit(kUnitIndex).outcome.goTarg.signalStrength(iPropIndex).epoch.(mEpochName).alignTime = alignmentIndex;
                if ~isempty(alignmentTimeList)
                    %                 sdf = nanmean(spike_density_function(alignedRasters, kernelMethod, GROWTH, DECAY));
                    sdf = nanmean(spike_density_function(alignedRasters, kernelMethod, SIGMA), 1);
                    sdfMax(kUnitIndex, mEpoch, iPropIndex, 1) = max(sdf);
                    Unit(kUnitIndex).outcome.goTarg.signalStrength(iPropIndex).epoch.(mEpochName).raster = alignedRasters;
                    Unit(kUnitIndex).outcome.goTarg.signalStrength(iPropIndex).epoch.(mEpochName).sdf = sdf;
                end
                
                % Go to Distractor trials
                alignmentTimeList = trialData.(mEpochName)(iGoDistTrial)
                [alignedRasters, alignmentIndex] = spike_to_raster(trialData.spikeData(iGoDistTrial, kUnitIndex), alignmentTimeList);
                Unit(kUnitIndex).outcome.goDist.signalStrength(iPropIndex).epoch.(mEpochName).alignTime = alignmentIndex;
                if ~isempty(alignmentTimeList)
                    %                 sdf = nanmean(spike_density_function(alignedRasters, kernelMethod, GROWTH, DECAY));
                    sdf = nanmean(spike_density_function(alignedRasters, kernelMethod, SIGMA), 1);
                    sdfMax(kUnitIndex, mEpoch, iPropIndex, 2) = max(sdf);
                    Unit(kUnitIndex).outcome.goDist.signalStrength(iPropIndex).epoch.(mEpochName).raster = alignedRasters;
                    Unit(kUnitIndex).outcome.goDist.signalStrength(iPropIndex).epoch.(mEpochName).sdf = sdf;
                end
            end
        end % mEpoch
        
        
        
        %         function Unit = spike_unit_data(Unit, kUnitIndex, conditionName, iPropIndex, mEpochName)
        
        
        
        
        % Stop trials
        %         for jSSDIndex = 1 : length(ssdArray)
        %             jSSD = ssdArray(jSSDIndex);
        jSSD = 'all';
        
        if iPct ~= 50 || (iPct == 50 &&  targ1PropArray(iPropIndex-1) ~= 50 &&  targ1PropArray(iPropIndex+1) ~= 50)
            targetHemifield = 'all';
        elseif iPct == 50 && targ1PropArray(iPropIndex-1) ~= 50
            targetHemifield = 'left';
        elseif iPct == 50 && targ1PropArray(iPropIndex-1) == 50
            targetHemifield = 'right';
        end
        jStopTargTrial = ccm_trial_selection(trialData,  {'stopIncorrectTarget', 'targetHoldAbort', 'stopIncorrectPreSSDTarget'}, iPct, jSSD, targetHemifield);
        jStopDistTrial = ccm_trial_selection(trialData,  {'stopIncorrectDistractor', 'distractorHoldAbort', 'stopIncorrectPreSSDDistractor'}, iPct, jSSD, targetHemifield);
        jStopTargTrial(ismember(jStopTargTrial, outlierTrial)) = [];
        jStopDistTrial(ismember(jStopDistTrial, outlierTrial)) = [];
        jStopCorrectTrial = ccm_trial_selection(trialData,  {'stopCorrect'}, iPct, jSSD, targetHemifield);
        
        
        for mEpoch = 1 : length(epochArray)
            mEpochName = epochArray{mEpoch};
            
            % Stop to Target trials
            alignmentTimeList = trialData.(mEpochName)(jStopTargTrial);
            [alignedRasters, alignmentIndex] = spike_to_raster(trialData.spikeData(jStopTargTrial, kUnitIndex), alignmentTimeList);
            Unit(kUnitIndex).outcome.stopTarg.signalStrength(iPropIndex).epoch.(mEpochName).alignTime = alignmentIndex;
            if ~isempty(alignmentTimeList)
                %                 sdf = nanmean(spike_density_function(alignedRasters, kernelMethod, GROWTH, DECAY));
                sdf = nanmean(spike_density_function(alignedRasters, kernelMethod, SIGMA), 1);
                sdfMax(kUnitIndex, mEpoch, iPropIndex, 3) = max(sdf);
                Unit(kUnitIndex).outcome.stopTarg.signalStrength(iPropIndex).epoch.(mEpochName).raster = alignedRasters;
                Unit(kUnitIndex).outcome.stopTarg.signalStrength(iPropIndex).epoch.(mEpochName).sdf = sdf;
            end
            
            % Stop to Distractor trials
            alignmentTimeList = trialData.(mEpochName)(jStopDistTrial);
            [alignedRasters, alignmentIndex] = spike_to_raster(trialData.spikeData(jStopDistTrial, kUnitIndex), alignmentTimeList);
            Unit(kUnitIndex).outcome.stopDist.signalStrength(iPropIndex).epoch.(mEpochName).alignTime = alignmentIndex;
            if ~isempty(alignmentTimeList)
                %                 sdf = nanmean(spike_density_function(alignedRasters, kernelMethod, GROWTH, DECAY));
                sdf = nanmean(spike_density_function(alignedRasters, kernelMethod, SIGMA), 1);
                sdfMax(kUnitIndex, mEpoch, iPropIndex, 4) = max(sdf);
                Unit(kUnitIndex).outcome.stopDist.signalStrength(iPropIndex).epoch.(mEpochName).raster = alignedRasters;
                Unit(kUnitIndex).outcome.stopDist.signalStrength(iPropIndex).epoch.(mEpochName).sdf = sdf;
            end
            
            if ~strcmp(mEpochName, 'responseOnset')  % No stop signals on go trials
                % Stop to Target trials
                alignmentTimeList = trialData.(mEpochName)(jStopCorrectTrial);
                [alignedRasters, alignmentIndex] = spike_to_raster(trialData.spikeData(jStopCorrectTrial, kUnitIndex), alignmentTimeList);
                Unit(kUnitIndex).outcome.stopCorrect.signalStrength(iPropIndex).epoch.(mEpochName).alignTime = alignmentIndex;
                if ~isempty(alignmentTimeList)
                    %                 sdf = nanmean(spike_density_function(alignedRasters, kernelMethod, GROWTH, DECAY));
                    sdf = nanmean(spike_density_function(alignedRasters, kernelMethod, SIGMA), 1);
                    sdfMax(kUnitIndex, mEpoch, iPropIndex, 5) = max(sdf);
                    Unit(kUnitIndex).outcome.stopCorrect.signalStrength(iPropIndex).epoch.(mEpochName).raster = alignedRasters;
                    Unit(kUnitIndex).outcome.stopCorrect.signalStrength(iPropIndex).epoch.(mEpochName).sdf = sdf;
                end
                
                %                 end % jSSD
            end % mEpoch
            
            
        end % jSSDIndex
    end %iPropIndex
    
    
    
    
    
    
    
    
    
    
    
end % kUnitIndex
disp('complete')

%%
plotFlag = 1;
if plotFlag
    colorGrad = length(targ1PropArray)/2;
    goC = zeros(colorGrad*2, 3);
    goC(1:colorGrad, 1:3) = repmat(linspace(0,.6,colorGrad)', 1, 3);
    stopC = goC;
    goC(1:colorGrad, 3) = linspace(.3,1,colorGrad);
    goC(colorGrad+1 : end, 1:3) = flipud(goC(1:colorGrad, :));
    stopC(1:colorGrad, 1) = linspace(.3,1,colorGrad);
    stopC(colorGrad+1 : end, 1:3) = flipud(stopC(1:colorGrad, :));
    
    %     leftC = zeros(colorGrad, 3);
    %     leftC(:, 1:3) = repmat(linspace(0,.6,colorGrad)', 1, 3);
    %     leftC(:, 3) = linspace(.4,1,colorGrad);
    %     rightC = zeros(colorGrad, 3);
    %     rightC(:, 1:3) = repmat(linspace(.6,0,colorGrad)', 1, 3);
    %     rightC(:, 2) = linspace(1,0.2,colorGrad);
    
    %     leftC = zeros(colorGrad, 3);
    %     leftC(:, 3) = linspace(1,0,colorGrad);
    %     leftC = hot(length(targ1PropArray)-2);
    %     rightC = flipud(hot(length(targ1PropArray)-2));
    figureHandle = 9283;
    for kUnitIndex = 1 : nUnit
        nRow = 3;
        nColumn = nEpoch * 2 + 1;
        nEpoch = length(epochArray);
        screenOrSave = 'screen';
        figureHandle = figureHandle + 1;
        [axisWidth, axisHeight, xAxesPosition, yAxesPosition] = screen_figure(nRow, nColumn, figureHandle, screenOrSave);
        clf
%         boxMargin = .5;
%         x = xAxesPosition(end, 1);% - boxMargin;
%         y = yAxesPosition(end, 1);% - boxMargin;
%         w = axisWidth * nColumn/2;
%         h = axisHeight * nRow;
%                 rectangle('Position', [x, y, w, h], 'edgecolor', 'b')
        for mEpoch = 1 : nEpoch
            mEpochName = epochArray{mEpoch};
            
            
            
            % _______  Set up axes  ___________
            % axes names
            axGo = 1;
            axStopGo = 2;
            axStopStop = 3;
            
            % Set up plot axes
            % Left target Go trials
            ax(axGo, mEpoch) = axes('units', 'centimeters', 'position', [xAxesPosition(axGo, mEpoch) yAxesPosition(axGo, mEpoch) axisWidth axisHeight]);
            set(ax(axGo, mEpoch), 'ylim', [0 max(sdfMax(kUnitIndex, :))], 'xlim', [epochRange(1) epochRange(end)])            
            cla
            hold(ax(axGo, mEpoch), 'on')
            plot(ax(axGo, mEpoch), [1 1], [0 max(sdfMax(kUnitIndex, :))], '-k', 'linewidth', 2)
            title(epochArray{mEpoch})

            % Right target Go trials
            ax(axGo, mEpoch+nEpoch) = axes('units', 'centimeters', 'position', [xAxesPosition(axGo, mEpoch+nEpoch+1) yAxesPosition(axGo, mEpoch+nEpoch+1) axisWidth axisHeight]);
            set(ax(axGo, mEpoch+nEpoch), 'ylim', [0 max(sdfMax(kUnitIndex, :))], 'xlim', [epochRange(1) epochRange(end)]) 
            cla
            hold(ax(axGo, mEpoch+nEpoch), 'on')
            plot(ax(axGo, mEpoch+nEpoch), [1 1], [0 max(sdfMax(kUnitIndex, :))], '-k', 'linewidth', 2)
             title(epochArray{mEpoch})
           %             set(ax(axRight, mEpoch), 'Xtick', [0 : 100 : epochRange(end) - epochRange(1)], 'XtickLabel', [epochRange(1) : 100: epochRange(end)])
            
            % Left target Stop Incorrect trials
            ax(axStopGo, mEpoch) = axes('units', 'centimeters', 'position', [xAxesPosition(axStopGo, mEpoch) yAxesPosition(axStopGo, mEpoch) axisWidth axisHeight]);
            set(ax(axStopGo, mEpoch), 'ylim', [0 max(sdfMax(kUnitIndex, :))], 'xlim', [epochRange(1) epochRange(end)]) 
            cla
            hold(ax(axStopGo, mEpoch), 'on')
            plot(ax(axStopGo, mEpoch), [1 1], [0 max(sdfMax(kUnitIndex, :))], '-k', 'linewidth', 2)

            % Right target Stop Incorrect trials
            ax(axStopGo, mEpoch+nEpoch) = axes('units', 'centimeters', 'position', [xAxesPosition(axStopGo, mEpoch+nEpoch+1) yAxesPosition(axStopGo, mEpoch+nEpoch+1) axisWidth axisHeight]);
            set(ax(axStopGo, mEpoch+nEpoch), 'ylim', [0 max(sdfMax(kUnitIndex, :))], 'xlim', [epochRange(1) epochRange(end)]) 
            cla
            hold(ax(axStopGo, mEpoch+nEpoch), 'on')
            plot(ax(axStopGo, mEpoch+nEpoch), [1 1], [0 max(sdfMax(kUnitIndex, :))], '-k', 'linewidth', 2)
            
            % Left target Stop Correct trials
            ax(axStopStop, mEpoch) = axes('units', 'centimeters', 'position', [xAxesPosition(axStopStop, mEpoch) yAxesPosition(axStopStop, mEpoch) axisWidth axisHeight]);
            set(ax(axStopStop, mEpoch), 'ylim', [0 max(sdfMax(kUnitIndex, :))], 'xlim', [epochRange(1) epochRange(end)]) 
            cla
            hold(ax(axStopStop, mEpoch), 'on')
            plot(ax(axStopStop, mEpoch), [1 1], [0 max(sdfMax(kUnitIndex, :))], '-k', 'linewidth', 2)

            % Right target Stop Correct trials
            ax(axStopStop, mEpoch+nEpoch) = axes('units', 'centimeters', 'position', [xAxesPosition(axStopStop, mEpoch+nEpoch+1) yAxesPosition(axStopStop, mEpoch+nEpoch+1) axisWidth axisHeight]);
            set(ax(axStopStop, mEpoch+nEpoch), 'ylim', [0 max(sdfMax(kUnitIndex, :))], 'xlim', [epochRange(1) epochRange(end)]) 
            cla
            hold(ax(axStopStop, mEpoch+nEpoch), 'on')
            plot(ax(axStopStop, mEpoch+nEpoch), [1 1], [0 max(sdfMax(kUnitIndex, :))], '-k', 'linewidth', 2)
            
            
           % __________ Loop signal strengths and plot  _________
            % First the left target trials
            for iPropIndex = 1 : nSignal/2
                
                if ~strcmp(mEpochName, 'stopSignalOn')  % No stop signals on go trials
                    alignGoTarg = Unit(kUnitIndex).outcome.goTarg.signalStrength(iPropIndex).epoch.(mEpochName).alignTime;
                    alignGoDist = Unit(kUnitIndex).outcome.goDist.signalStrength(iPropIndex).epoch.(mEpochName).alignTime;
                    if ~isempty(alignGoTarg)
                        sdfGoTarg = Unit(kUnitIndex).outcome.goTarg.signalStrength(iPropIndex).epoch.(mEpochName).sdf;
                        plot(ax(axGo, mEpoch), epochRange, sdfGoTarg(alignGoTarg + epochRange), 'color', goC(iPropIndex,:), 'linewidth', 4)
                    end
                    if ~isempty(alignGoDist)
                        sdfGoDist = Unit(kUnitIndex).outcome.goDist.signalStrength(iPropIndex).epoch.(mEpochName).sdf;
                        plot(ax(axGo, mEpoch), epochRange, sdfGoDist(alignGoDist + epochRange), '--', 'color', goC(iPropIndex,:), 'linewidth', 2)
                    end
                end
                
                
                alignStopTarg = Unit(kUnitIndex).outcome.stopTarg.signalStrength(iPropIndex).epoch.(mEpochName).alignTime;
                alignStopDist = Unit(kUnitIndex).outcome.stopDist.signalStrength(iPropIndex).epoch.(mEpochName).alignTime;
                if ~isempty(alignStopTarg)
                    sdfStopTarg = Unit(kUnitIndex).outcome.stopTarg.signalStrength(iPropIndex).epoch.(mEpochName).sdf;
                    plot(ax(axStopGo, mEpoch), epochRange, sdfStopTarg(alignStopTarg + epochRange), 'color', stopC(iPropIndex,:), 'linewidth', 4)
                end
                if ~isempty(alignStopDist)
                    sdfStopDist = Unit(kUnitIndex).outcome.stopDist.signalStrength(iPropIndex).epoch.(mEpochName).sdf;
                    plot(ax(axStopGo, mEpoch), epochRange, sdfStopDist(alignStopDist + epochRange), '--', 'color', stopC(iPropIndex,:), 'linewidth', 2)
                end
                
                
                if ~strcmp(mEpochName, 'responseOnset')  % No stop signals on go trials
                    alignStopCorrect = Unit(kUnitIndex).outcome.stopCorrect.signalStrength(iPropIndex).epoch.(mEpochName).alignTime;
                    if ~isempty(alignStopCorrect)
                        sdfStopCorrect = Unit(kUnitIndex).outcome.stopCorrect.signalStrength(iPropIndex).epoch.(mEpochName).sdf;
                        plot(ax(axStopStop, mEpoch), epochRange, sdfStopCorrect(alignStopCorrect + epochRange), 'color', stopC(iPropIndex,:), 'linewidth', 2)
                    end
                end
                   
                    
                % Then the right target trials
                iPropIndexR = nSignal + 1 - iPropIndex;  % Reverse order of plotting to keep color overlays similar between left and right target
                
                if ~strcmp(mEpochName, 'stopSignalOn')  % No stop signals on go trials
                    alignGoTarg = Unit(kUnitIndex).outcome.goTarg.signalStrength(iPropIndexR).epoch.(mEpochName).alignTime;
                    alignGoDist = Unit(kUnitIndex).outcome.goDist.signalStrength(iPropIndexR).epoch.(mEpochName).alignTime;
                    if ~isempty(alignGoTarg)
                        sdfGoTarg = Unit(kUnitIndex).outcome.goTarg.signalStrength(iPropIndexR).epoch.(mEpochName).sdf;
                        plot(ax(axGo, mEpoch + nEpoch), epochRange, sdfGoTarg(alignGoTarg + epochRange), 'color', goC(iPropIndexR,:), 'linewidth', 2)
                    end
                    if ~isempty(alignGoDist)
                        sdfGoDist = Unit(kUnitIndex).outcome.goDist.signalStrength(iPropIndexR).epoch.(mEpochName).sdf;
                        plot(ax(axGo, mEpoch + nEpoch), epochRange, sdfGoDist(alignGoDist + epochRange), '--', 'color', goC(iPropIndexR,:), 'linewidth', 2)
                    end
                end
                alignStopTarg = Unit(kUnitIndex).outcome.stopTarg.signalStrength(iPropIndexR).epoch.(mEpochName).alignTime;
                alignStopDist = Unit(kUnitIndex).outcome.stopDist.signalStrength(iPropIndexR).epoch.(mEpochName).alignTime;
                if ~isempty(alignStopTarg)
                    sdfStopTarg = Unit(kUnitIndex).outcome.stopTarg.signalStrength(iPropIndexR).epoch.(mEpochName).sdf;
                    plot(ax(axStopGo, mEpoch + nEpoch), epochRange, sdfStopTarg(alignStopTarg + epochRange), 'color', stopC(iPropIndexR,:), 'linewidth', 2)
                end
                if ~isempty(alignStopDist)
                    sdfStopDist = Unit(kUnitIndex).outcome.stopDist.signalStrength(iPropIndexR).epoch.(mEpochName).sdf;
                    plot(ax(axStopGo, mEpoch + nEpoch), epochRange, sdfStopDist(alignStopDist + epochRange), '--', 'color', stopC(iPropIndexR,:), 'linewidth', 2)
                end
               
                
                if ~strcmp(mEpochName, 'responseOnset')  % No stop signals on go trials
                    alignStopCorrect = Unit(kUnitIndex).outcome.stopCorrect.signalStrength(iPropIndexR).epoch.(mEpochName).alignTime;
                    if ~isempty(alignStopCorrect)
                        sdfStopCorrect = Unit(kUnitIndex).outcome.stopCorrect.signalStrength(iPropIndexR).epoch.(mEpochName).sdf;
                        plot(ax(axStopStop, mEpoch + nEpoch), epochRange, sdfStopCorrect(alignStopCorrect + epochRange), 'color', stopC(iPropIndexR,:), 'linewidth', 2)
                    end
                end
            end % iPropIndex
%                       if mEpoch == 3
%                 colormap(goC);
%                 legend(ax(axGo, 1), '
            end
       
        end % mEpoch
                colorbar('peer', ax(axGo, 1), 'location', 'west')
                colorbar('peer', ax(axStopGo, 1), 'location', 'west')
    end % kUnitIndex
    
end % plotFlag

